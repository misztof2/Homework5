#include <iostream>
#include <vector>
#include <SFML/Window.hpp>
#include <SFML/Graphics.hpp>

class CustomSprite : public sf::Sprite {
public:
    void setBounds(int left, int right, int top, int bottom) {
        bound_top = top;
        bound_bottom = bottom;
        bound_right = right;
        bound_left = left;
    }

    bool Collision_T(sf::FloatRect wall_bounds, sf::FloatRect guy_bounds) {
        return (guy_bounds.top + guy_bounds.height >= wall_bounds.top - 3) &&
               (guy_bounds.top < wall_bounds.top) &&
               (guy_bounds.left + guy_bounds.width > wall_bounds.left + 3) &&
               (guy_bounds.left < wall_bounds.left + wall_bounds.width - 3);
    }

    void moveInDirection(const sf::Time &elapsed, const std::vector<sf::Sprite> &obstacles) {
        float distance = m_speed_y * elapsed.asSeconds();
        sf::FloatRect rectangle_bounds = getGlobalBounds();

        bool canMoveUp = true, canMoveDown = true, canMoveLeft = true, canMoveRight = true;

        for (auto &obstacle : obstacles) {
            sf::FloatRect guy_bounds = getGlobalBounds();
            sf::FloatRect wall_bounds = obstacle.getGlobalBounds();

            if (Collision_T(wall_bounds, guy_bounds)) {
                canMoveUp = false;
            }
        }

        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up) && rectangle_bounds.top > bound_top && canMoveUp)
            move(0, -distance);
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down) && rectangle_bounds.top + rectangle_bounds.height < bound_bottom && canMoveDown)
            move(0, distance);
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left) && rectangle_bounds.left > bound_left && canMoveLeft)
            move(-distance, 0);
        if (sf::Keyboard::isKeyPressed(sf::Keyboard::Right) && rectangle_bounds.left + rectangle_bounds.width < bound_right && canMoveRight)
            move(distance, 0);
    }

private:
    int m_speed_x = 200;
    int m_speed_y = 200;
    int bound_top = 0, bound_bottom = 0, bound_left = 0, bound_right = 0;
};

int main() {
    sf::RenderWindow window(sf::VideoMode(800, 600), "Maze Game");
    sf::Clock clock;

    // Load Textures
    sf::Texture guy_tex, grass_tex, wall_tex;

    if (!guy_tex.loadFromFile("guy.png") ||
        !grass_tex.loadFromFile("grass.png") ||
        !wall_tex.loadFromFile("wall.png")) {
        std::cerr << "Failed to load one or more textures.\n";
        return -1;
    }

    // Grass Background
    sf::Sprite grass;
    grass.setTexture(grass_tex);
    grass.setScale(800.f / grass_tex.getSize().x, 600.f / grass_tex.getSize().y);

    // Walls (maze structure)
    std::vector<sf::Sprite> walls;
    for (int i = 0; i < 6; ++i) {
        sf::Sprite wall;
        wall.setTexture(wall_tex);
        wall.setScale(0.5f, 0.5f);
        walls.push_back(wall);
    }

    walls[0].setPosition(200, 100);
    walls[1].setPosition(200, 150);
    walls[2].setPosition(200, 200);
    walls[3].setPosition(300, 100);
    walls[4].setPosition(400, 100);
    walls[5].setPosition(400, 150);

    // Guy (player)
    CustomSprite guy;
    guy.setTexture(guy_tex);
    guy.setScale(0.3f, 0.3f);
    guy.setPosition(100, 100);

    while (window.isOpen()) {
        sf::Time elapsed = clock.restart();

        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();
        }

        guy.setBounds(0, window.getSize().x, 0, window.getSize().y);
        guy.moveInDirection(elapsed, walls);

        window.clear();
        window.draw(grass);
        for (auto &wall : walls) window.draw(wall);
        window.draw(guy);
        window.display();
    }

    return 0;
}
